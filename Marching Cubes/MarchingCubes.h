#pragma once

typedef signed char				int8;
typedef short					int16;
typedef int						int32;
typedef __int64					int64;
typedef unsigned char			uint8;
typedef unsigned short			uint16;
typedef unsigned int			uint32;
typedef unsigned __int64		uint64;

struct Vector3D {
	float x;
	float y;
	float z;
	Vector3D(int _x = 0, int _y = 0, int _z = 0);
	Vector3D(const Vector3D& v);
};

struct Vertex {
	Vector3D position;
};

struct Triangle {
	uint16 index[3];
};

template<int sizeX, int sizeY, int sizeZ, class T>
class VolumetricData
{
private:
	T data[sizeX][sizeY][sizeZ];
public:
	VolumetricData(T data[sizeX][sizeY][sizeZ]);
	VolumetricData(const VolumetricData<sizeX, sizeY, sizeZ, T>& volumetricData);
	T get(int x, int y, int z);
};

template<int cubeCountX, int cubeCountY, int cubeCountZ>
class MarchedGeometry
{
	const static int MAX_TRIANGLE_PER_CUBE = 5;
	const static int MAX_VERTEX_PER_CUBE = 12;
	const static int CASE_COUNT = 256;
	const static int CLASS_COUNT = 16;
	const static int EDGE_COUNT = 12;
	const static int CORNER_COUNT = 8;
	enum
	{
		cubeCount = cubeCountX * cubeCountY * cubeCountZ,
		maxVertexCount = cubeCount * MAX_VERTEX_PER_CUBE,
		maxTriangleCount = cubeCount * MAX_TRIANGLE_PER_CUBE,
	};
	struct ClassGeometry
	{
		typedef struct _GeometryCount {
			unsigned char triangleCount : 4;
			unsigned char vertexCount : 4;
		}GeometryCount;
		union {
			uint8 value;
			GeometryCount geometryCounts;
		};
		uint8 vertexIndex[MAX_TRIANGLE_PER_CUBE * 3];
	};
	struct OnEdgeVertexCode
	{
		typedef struct _CodeBits {
			unsigned char lowerNumberedCorner : 3;
			unsigned char higherNumberedCorner : 3;
			unsigned char reducedEdgeIndex : 2;
			unsigned char edgeIndex : 4;
			unsigned char edgeDelta : 4;
		}CodeBits;
		union {
			uint16 value;
			CodeBits parts;
		};
	};
	struct ReusableCubeData
	{
		const static int REUSABLE_EDGE_COUNT = 9;
		const static int REUSABLE_CORNER_COUNT = 7;
		const static uint16 BLANK = 0xFFFF;
		uint16 corner[REUSABLE_CORNER_COUNT];
		uint16 edge[REUSABLE_EDGE_COUNT];
		void reset();
		void setCorner(uint8 cornerIndex, uint16 value);
		uint16 getCorner(uint8 cornerIndex);
		void setEdge(uint8 edgeIndex, uint16 value);
		uint16 getEdge(uint8 edgeIndex);
	};
private:
	Vector3D cubeScale;
	Vector3D size;
	VolumetricData<cubeCountX + 1, cubeCountY + 1, cubeCountZ + 1, int8> field;

	int vertexCount;
	int triangleCount;
	Vertex vertex[maxVertexCount];
	Triangle triangle[maxTriangleCount];

	static const uint8 caseIndexToClassIndex[CASE_COUNT];
	static const ClassGeometry classGeometry[CLASS_COUNT];
	static const OnEdgeVertexCode onEdgeVertexCode[CASE_COUNT][MAX_VERTEX_PER_CUBE];

	int8 getCornerFieldValue(int x, int y, int z, int cornerIndex);
	uint32 getCaseIndex(int x, int y, int z);
	uint32 getCornerDeltaMask(int x, int y, int z);
	uint32 getEdgeDeltaMask(int x, int y, int z);
	int32 getInterpolationT(int x, int y, int z, OnEdgeVertexCode code);
	uint16 getVertexIndexOnCorner(int x, int y, int z, OnEdgeVertexCode code, int32 interpolationT, ReusableCubeData deck[2][cubeCountX][cubeCountY]);
	uint16 getNewVertexIndexOnCorner(int x, int y, int z, uint8 cornerIndex);
	uint16 getVertexIndexOnEdge(int x, int y, int z, OnEdgeVertexCode code, int32 interpolationT, ReusableCubeData deck[2][cubeCountX][cubeCountY]);
	uint16 getNewVertexIndexOnEdge(int x, int y, int z, OnEdgeVertexCode code, int32 interpolationT);
	bool isTriangleAreaZero(int triangleIndex);
	void setVertex(uint16 vertexIndex, float xPos, float yPos, float zPos);
	void marchCubes();
	void marchCube(int x, int y, int z, ReusableCubeData deck[2][cubeCountX][cubeCountY]);
public:
	MarchedGeometry(Vector3D cubeScale, VolumetricData<cubeCountX + 1, cubeCountY + 1, cubeCountZ + 1, int8>);
	~MarchedGeometry();
};

// The following function are not in MarchingCubes.cpp due to linker errors.
// for more information refer to https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl

template<int sizeX, int sizeY, int sizeZ, typename T>
VolumetricData<sizeX, sizeY, sizeZ, T>::VolumetricData(T data[sizeX][sizeY][sizeZ]) {
	for (int i = 0; i < sizeX; i++)
	{
		for (int j = 0; j < sizeY; j++)
		{
			for (int k = 0; k < sizeZ; k++)
			{
				this->data[i][j][k] = data[i][j][k];
			}
		}
	}
}

template<int sizeX, int sizeY, int sizeZ, typename T>
VolumetricData<sizeX, sizeY, sizeZ, T>::VolumetricData(const VolumetricData<sizeX, sizeY, sizeZ, T>& volumetricData) {
	for (int i = 0; i < sizeX; i++)
	{
		for (int j = 0; j < sizeY; j++)
		{
			for (int k = 0; k < sizeZ; k++)
			{
				this->data[i][j][k] = volumetricData.data[i][j][k];
			}
		}
	}
}

template<int sizeX, int sizeY, int sizeZ, typename T>
T VolumetricData<sizeX, sizeY, sizeZ, T>::get(int x, int y, int z) {
	return this->data[x][y][z];
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
const uint8 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::caseIndexToClassIndex[MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::CASE_COUNT] = {
	0x00, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x04, 0x01, 0x02, 0x03, 0x04, 0x03, 0x04, 0x04, 0x03,
	0x01, 0x03, 0x02, 0x04, 0x02, 0x04, 0x06, 0x0C, 0x02, 0x05, 0x05, 0x0B, 0x05, 0x0A, 0x07, 0x04,
	0x01, 0x02, 0x03, 0x04, 0x02, 0x05, 0x05, 0x0A, 0x02, 0x06, 0x04, 0x0C, 0x05, 0x07, 0x0B, 0x04,
	0x03, 0x04, 0x04, 0x03, 0x05, 0x0B, 0x07, 0x04, 0x05, 0x07, 0x0A, 0x04, 0x08, 0x0E, 0x0E, 0x03,
	0x01, 0x02, 0x02, 0x05, 0x03, 0x04, 0x05, 0x0B, 0x02, 0x06, 0x05, 0x07, 0x04, 0x0C, 0x0A, 0x04,
	0x03, 0x04, 0x05, 0x0A, 0x04, 0x03, 0x07, 0x04, 0x05, 0x07, 0x08, 0x0E, 0x0B, 0x04, 0x0E, 0x03,
	0x02, 0x06, 0x05, 0x07, 0x05, 0x07, 0x08, 0x0E, 0x06, 0x09, 0x07, 0x0F, 0x07, 0x0F, 0x0E, 0x0D,
	0x04, 0x0C, 0x0B, 0x04, 0x0A, 0x04, 0x0E, 0x03, 0x07, 0x0F, 0x0E, 0x0D, 0x0E, 0x0D, 0x02, 0x01,
	0x01, 0x02, 0x02, 0x05, 0x02, 0x05, 0x06, 0x07, 0x03, 0x05, 0x04, 0x0A, 0x04, 0x0B, 0x0C, 0x04,
	0x02, 0x05, 0x06, 0x07, 0x06, 0x07, 0x09, 0x0F, 0x05, 0x08, 0x07, 0x0E, 0x07, 0x0E, 0x0F, 0x0D,
	0x03, 0x05, 0x04, 0x0B, 0x05, 0x08, 0x07, 0x0E, 0x04, 0x07, 0x03, 0x04, 0x0A, 0x0E, 0x04, 0x03,
	0x04, 0x0A, 0x0C, 0x04, 0x07, 0x0E, 0x0F, 0x0D, 0x0B, 0x0E, 0x04, 0x03, 0x0E, 0x02, 0x0D, 0x01,
	0x03, 0x05, 0x05, 0x08, 0x04, 0x0A, 0x07, 0x0E, 0x04, 0x07, 0x0B, 0x0E, 0x03, 0x04, 0x04, 0x03,
	0x04, 0x0B, 0x07, 0x0E, 0x0C, 0x04, 0x0F, 0x0D, 0x0A, 0x0E, 0x0E, 0x02, 0x04, 0x03, 0x0D, 0x01,
	0x04, 0x07, 0x0A, 0x0E, 0x0B, 0x0E, 0x0E, 0x02, 0x0C, 0x0F, 0x04, 0x0D, 0x04, 0x0D, 0x03, 0x01,
	0x03, 0x04, 0x04, 0x03, 0x04, 0x03, 0x0D, 0x01, 0x04, 0x0D, 0x03, 0x01, 0x03, 0x01, 0x01, 0x00
};

template<int cubeCountX, int cubeCountY, int cubeCountZ>
const typename MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::ClassGeometry MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::classGeometry[MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::CLASS_COUNT] = {
	{0x00, {}},
	{0x31, {0, 1, 2}},
	{0x62, {0, 1, 2, 3, 4, 5}},
	{0x42, {0, 1, 2, 0, 2, 3}},
	{0x53, {0, 1, 4, 1, 3, 4, 1, 2, 3}},
	{0x73, {0, 1, 2, 0, 2, 3, 4, 5, 6}},
	{0x93, {0, 1, 2, 3, 4, 5, 6, 7, 8}},
	{0x84, {0, 1, 4, 1, 3, 4, 1, 2, 3, 5, 6, 7}},
	{0x84, {0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7}},
	{0xC4, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}},
	{0x64, {0, 4, 5, 0, 1, 4, 1, 3, 4, 1, 2, 3}},
	{0x64, {0, 5, 4, 0, 4, 1, 1, 4, 3, 1, 3, 2}},
	{0x64, {0, 4, 5, 0, 3, 4, 0, 1, 3, 1, 2, 3}},
	{0x64, {0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5}},
	{0x75, {0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6}},
	{0x95, {0, 4, 5, 0, 3, 4, 0, 1, 3, 1, 2, 3, 6, 7, 8}}
};

template<int cubeCountX, int cubeCountY, int cubeCountZ>
const typename MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::OnEdgeVertexCode MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::onEdgeVertexCode[MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::CASE_COUNT][MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::MAX_VERTEX_PER_CUBE] = {
	{},
	{0xA188, 0x9050, 0x72E0},
	{0xA188, 0x65E9, 0x8359},
	{0x9050, 0x72E0, 0x65E9, 0x8359},
	{0x9050, 0x849A, 0x18F2},
	{0x72E0, 0xA188, 0x849A, 0x18F2},
	{0xA188, 0x65E9, 0x8359, 0x9050, 0x849A, 0x18F2},
	{0x849A, 0x18F2, 0x72E0, 0x65E9, 0x8359},
	{0x8359, 0x0BFB, 0x849A},
	{0xA188, 0x9050, 0x72E0, 0x849A, 0x8359, 0x0BFB},
	{0xA188, 0x65E9, 0x0BFB, 0x849A},
	{0x9050, 0x72E0, 0x65E9, 0x0BFB, 0x849A},
	{0x9050, 0x8359, 0x0BFB, 0x18F2},
	{0x8359, 0x0BFB, 0x18F2, 0x72E0, 0xA188},
	{0xA188, 0x65E9, 0x0BFB, 0x18F2, 0x9050},
	{0x72E0, 0x65E9, 0x0BFB, 0x18F2},
	{0x72E0, 0x1674, 0x27AC},
	{0xA188, 0x9050, 0x1674, 0x27AC},
	{0xA188, 0x65E9, 0x8359, 0x72E0, 0x1674, 0x27AC},
	{0x65E9, 0x8359, 0x9050, 0x1674, 0x27AC},
	{0x9050, 0x849A, 0x18F2, 0x72E0, 0x1674, 0x27AC},
	{0x1674, 0x27AC, 0xA188, 0x849A, 0x18F2},
	{0x72E0, 0x1674, 0x27AC, 0xA188, 0x65E9, 0x8359, 0x9050, 0x849A, 0x18F2},
	{0x849A, 0x18F2, 0x1674, 0x27AC, 0x65E9, 0x8359},
	{0x849A, 0x8359, 0x0BFB, 0x72E0, 0x1674, 0x27AC},
	{0xA188, 0x9050, 0x1674, 0x27AC, 0x849A, 0x8359, 0x0BFB},
	{0x849A, 0xA188, 0x65E9, 0x0BFB, 0x72E0, 0x1674, 0x27AC},
	{0x849A, 0x0BFB, 0x65E9, 0x27AC, 0x1674, 0x9050},
	{0x9050, 0x8359, 0x0BFB, 0x18F2, 0x72E0, 0x1674, 0x27AC},
	{0x8359, 0x0BFB, 0x18F2, 0x1674, 0x27AC, 0xA188},
	{0xA188, 0x65E9, 0x0BFB, 0x18F2, 0x9050, 0x72E0, 0x1674, 0x27AC},
	{0x27AC, 0x65E9, 0x0BFB, 0x18F2, 0x1674},
	{0x65E9, 0x27AC, 0x097D},
	{0xA188, 0x9050, 0x72E0, 0x65E9, 0x27AC, 0x097D},
	{0x8359, 0xA188, 0x27AC, 0x097D},
	{0x27AC, 0x097D, 0x8359, 0x9050, 0x72E0},
	{0x9050, 0x849A, 0x18F2, 0x65E9, 0x27AC, 0x097D},
	{0xA188, 0x849A, 0x18F2, 0x72E0, 0x65E9, 0x27AC, 0x097D},
	{0xA188, 0x27AC, 0x097D, 0x8359, 0x9050, 0x849A, 0x18F2},
	{0x849A, 0x18F2, 0x72E0, 0x27AC, 0x097D, 0x8359},
	{0x849A, 0x8359, 0x0BFB, 0x65E9, 0x27AC, 0x097D},
	{0xA188, 0x9050, 0x72E0, 0x849A, 0x8359, 0x0BFB, 0x65E9, 0x27AC, 0x097D},
	{0x0BFB, 0x849A, 0xA188, 0x27AC, 0x097D},
	{0x9050, 0x72E0, 0x27AC, 0x097D, 0x0BFB, 0x849A},
	{0x9050, 0x8359, 0x0BFB, 0x18F2, 0x65E9, 0x27AC, 0x097D},
	{0x8359, 0x0BFB, 0x18F2, 0x72E0, 0xA188, 0x65E9, 0x27AC, 0x097D},
	{0x9050, 0x18F2, 0x0BFB, 0x097D, 0x27AC, 0xA188},
	{0x097D, 0x0BFB, 0x18F2, 0x72E0, 0x27AC},
	{0x65E9, 0x72E0, 0x1674, 0x097D},
	{0xA188, 0x9050, 0x1674, 0x097D, 0x65E9},
	{0x72E0, 0x1674, 0x097D, 0x8359, 0xA188},
	{0x8359, 0x9050, 0x1674, 0x097D},
	{0x65E9, 0x72E0, 0x1674, 0x097D, 0x9050, 0x849A, 0x18F2},
	{0x18F2, 0x849A, 0xA188, 0x65E9, 0x097D, 0x1674},
	{0x72E0, 0x1674, 0x097D, 0x8359, 0xA188, 0x9050, 0x849A, 0x18F2},
	{0x18F2, 0x1674, 0x097D, 0x8359, 0x849A},
	{0x65E9, 0x72E0, 0x1674, 0x097D, 0x849A, 0x8359, 0x0BFB},
	{0xA188, 0x9050, 0x1674, 0x097D, 0x65E9, 0x849A, 0x8359, 0x0BFB},
	{0x72E0, 0x1674, 0x097D, 0x0BFB, 0x849A, 0xA188},
	{0x849A, 0x9050, 0x1674, 0x097D, 0x0BFB},
	{0x65E9, 0x72E0, 0x1674, 0x097D, 0x9050, 0x8359, 0x0BFB, 0x18F2},
	{0xA188, 0x8359, 0x0BFB, 0x18F2, 0x1674, 0x097D, 0x65E9},
	{0xA188, 0x72E0, 0x1674, 0x097D, 0x0BFB, 0x18F2, 0x9050},
	{0x18F2, 0x1674, 0x097D, 0x0BFB},
	{0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x9050, 0x72E0, 0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x65E9, 0x8359, 0x18F2, 0x0ABE, 0x1674},
	{0x9050, 0x72E0, 0x65E9, 0x8359, 0x18F2, 0x0ABE, 0x1674},
	{0x9050, 0x849A, 0x0ABE, 0x1674},
	{0x72E0, 0xA188, 0x849A, 0x0ABE, 0x1674},
	{0x9050, 0x849A, 0x0ABE, 0x1674, 0xA188, 0x65E9, 0x8359},
	{0x1674, 0x0ABE, 0x849A, 0x8359, 0x65E9, 0x72E0},
	{0x8359, 0x0BFB, 0x849A, 0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x9050, 0x72E0, 0x849A, 0x8359, 0x0BFB, 0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x65E9, 0x0BFB, 0x849A, 0x18F2, 0x0ABE, 0x1674},
	{0x9050, 0x72E0, 0x65E9, 0x0BFB, 0x849A, 0x18F2, 0x0ABE, 0x1674},
	{0x0ABE, 0x1674, 0x9050, 0x8359, 0x0BFB},
	{0xA188, 0x8359, 0x0BFB, 0x0ABE, 0x1674, 0x72E0},
	{0xA188, 0x65E9, 0x0BFB, 0x0ABE, 0x1674, 0x9050},
	{0x1674, 0x72E0, 0x65E9, 0x0BFB, 0x0ABE},
	{0x72E0, 0x18F2, 0x0ABE, 0x27AC},
	{0x18F2, 0x0ABE, 0x27AC, 0xA188, 0x9050},
	{0x72E0, 0x18F2, 0x0ABE, 0x27AC, 0xA188, 0x65E9, 0x8359},
	{0x18F2, 0x0ABE, 0x27AC, 0x65E9, 0x8359, 0x9050},
	{0x9050, 0x849A, 0x0ABE, 0x27AC, 0x72E0},
	{0xA188, 0x849A, 0x0ABE, 0x27AC},
	{0x9050, 0x849A, 0x0ABE, 0x27AC, 0x72E0, 0xA188, 0x65E9, 0x8359},
	{0x8359, 0x849A, 0x0ABE, 0x27AC, 0x65E9},
	{0x72E0, 0x18F2, 0x0ABE, 0x27AC, 0x849A, 0x8359, 0x0BFB},
	{0x18F2, 0x0ABE, 0x27AC, 0xA188, 0x9050, 0x849A, 0x8359, 0x0BFB},
	{0x72E0, 0x18F2, 0x0ABE, 0x27AC, 0x849A, 0xA188, 0x65E9, 0x0BFB},
	{0x9050, 0x18F2, 0x0ABE, 0x27AC, 0x65E9, 0x0BFB, 0x849A},
	{0x72E0, 0x27AC, 0x0ABE, 0x0BFB, 0x8359, 0x9050},
	{0x0BFB, 0x0ABE, 0x27AC, 0xA188, 0x8359},
	{0x9050, 0xA188, 0x65E9, 0x0BFB, 0x0ABE, 0x27AC, 0x72E0},
	{0x65E9, 0x0BFB, 0x0ABE, 0x27AC},
	{0x65E9, 0x27AC, 0x097D, 0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x9050, 0x72E0, 0x65E9, 0x27AC, 0x097D, 0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x27AC, 0x097D, 0x8359, 0x18F2, 0x0ABE, 0x1674},
	{0x27AC, 0x097D, 0x8359, 0x9050, 0x72E0, 0x18F2, 0x0ABE, 0x1674},
	{0x849A, 0x0ABE, 0x1674, 0x9050, 0x65E9, 0x27AC, 0x097D},
	{0x72E0, 0xA188, 0x849A, 0x0ABE, 0x1674, 0x65E9, 0x27AC, 0x097D},
	{0x849A, 0x0ABE, 0x1674, 0x9050, 0xA188, 0x27AC, 0x097D, 0x8359},
	{0x72E0, 0x27AC, 0x097D, 0x8359, 0x849A, 0x0ABE, 0x1674},
	{0x849A, 0x8359, 0x0BFB, 0x65E9, 0x27AC, 0x097D, 0x18F2, 0x0ABE, 0x1674},
	{0xA188, 0x9050, 0x72E0, 0x849A, 0x8359, 0x0BFB, 0x65E9, 0x27AC, 0x097D, 0x18F2, 0x0ABE, 0x1674},
	{0x0BFB, 0x849A, 0xA188, 0x27AC, 0x097D, 0x18F2, 0x0ABE, 0x1674},
	{0x849A, 0x9050, 0x72E0, 0x27AC, 0x097D, 0x0BFB, 0x18F2, 0x0ABE, 0x1674},
	{0x0ABE, 0x1674, 0x9050, 0x8359, 0x0BFB, 0x65E9, 0x27AC, 0x097D},
	{0xA188, 0x8359, 0x0BFB, 0x0ABE, 0x1674, 0x72E0, 0x65E9, 0x27AC, 0x097D},
	{0x0BFB, 0x0ABE, 0x1674, 0x9050, 0xA188, 0x27AC, 0x097D},
	{0x72E0, 0x27AC, 0x097D, 0x0BFB, 0x0ABE, 0x1674},
	{0x097D, 0x65E9, 0x72E0, 0x18F2, 0x0ABE},
	{0x0ABE, 0x097D, 0x65E9, 0xA188, 0x9050, 0x18F2},
	{0x0ABE, 0x18F2, 0x72E0, 0xA188, 0x8359, 0x097D},
	{0x0ABE, 0x097D, 0x8359, 0x9050, 0x18F2},
	{0x9050, 0x849A, 0x0ABE, 0x097D, 0x65E9, 0x72E0},
	{0x65E9, 0xA188, 0x849A, 0x0ABE, 0x097D},
	{0x72E0, 0x9050, 0x849A, 0x0ABE, 0x097D, 0x8359, 0xA188},
	{0x8359, 0x849A, 0x0ABE, 0x097D},
	{0x097D, 0x65E9, 0x72E0, 0x18F2, 0x0ABE, 0x849A, 0x8359, 0x0BFB},
	{0x097D, 0x65E9, 0xA188, 0x9050, 0x18F2, 0x0ABE, 0x849A, 0x8359, 0x0BFB},
	{0x097D, 0x0BFB, 0x849A, 0xA188, 0x72E0, 0x18F2, 0x0ABE},
	{0x9050, 0x18F2, 0x0ABE, 0x097D, 0x0BFB, 0x849A},
	{0x0ABE, 0x097D, 0x65E9, 0x72E0, 0x9050, 0x8359, 0x0BFB},
	{0xA188, 0x8359, 0x0BFB, 0x0ABE, 0x097D, 0x65E9},
	{0xA188, 0x72E0, 0x9050, 0x0BFB, 0x0ABE, 0x097D},
	{0x0BFB, 0x0ABE, 0x097D},
	{0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x9050, 0x72E0, 0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x65E9, 0x8359, 0x0BFB, 0x097D, 0x0ABE},
	{0x9050, 0x72E0, 0x65E9, 0x8359, 0x0BFB, 0x097D, 0x0ABE},
	{0x9050, 0x849A, 0x18F2, 0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x849A, 0x18F2, 0x72E0, 0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x65E9, 0x8359, 0x9050, 0x849A, 0x18F2, 0x0BFB, 0x097D, 0x0ABE},
	{0x849A, 0x18F2, 0x72E0, 0x65E9, 0x8359, 0x0BFB, 0x097D, 0x0ABE},
	{0x8359, 0x097D, 0x0ABE, 0x849A},
	{0x849A, 0x8359, 0x097D, 0x0ABE, 0xA188, 0x9050, 0x72E0},
	{0x097D, 0x0ABE, 0x849A, 0xA188, 0x65E9},
	{0x72E0, 0x65E9, 0x097D, 0x0ABE, 0x849A, 0x9050},
	{0x18F2, 0x9050, 0x8359, 0x097D, 0x0ABE},
	{0x097D, 0x8359, 0xA188, 0x72E0, 0x18F2, 0x0ABE},
	{0x18F2, 0x9050, 0xA188, 0x65E9, 0x097D, 0x0ABE},
	{0x0ABE, 0x18F2, 0x72E0, 0x65E9, 0x097D},
	{0x72E0, 0x1674, 0x27AC, 0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x9050, 0x1674, 0x27AC, 0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x65E9, 0x8359, 0x72E0, 0x1674, 0x27AC, 0x0BFB, 0x097D, 0x0ABE},
	{0x65E9, 0x8359, 0x9050, 0x1674, 0x27AC, 0x0BFB, 0x097D, 0x0ABE},
	{0x9050, 0x849A, 0x18F2, 0x72E0, 0x1674, 0x27AC, 0x0BFB, 0x097D, 0x0ABE},
	{0x1674, 0x27AC, 0xA188, 0x849A, 0x18F2, 0x0BFB, 0x097D, 0x0ABE},
	{0xA188, 0x65E9, 0x8359, 0x9050, 0x849A, 0x18F2, 0x72E0, 0x1674, 0x27AC, 0x0BFB, 0x097D, 0x0ABE},
	{0x8359, 0x849A, 0x18F2, 0x1674, 0x27AC, 0x65E9, 0x0BFB, 0x097D, 0x0ABE},
	{0x849A, 0x8359, 0x097D, 0x0ABE, 0x72E0, 0x1674, 0x27AC},
	{0xA188, 0x9050, 0x1674, 0x27AC, 0x849A, 0x8359, 0x097D, 0x0ABE},
	{0x097D, 0x0ABE, 0x849A, 0xA188, 0x65E9, 0x72E0, 0x1674, 0x27AC},
	{0x65E9, 0x097D, 0x0ABE, 0x849A, 0x9050, 0x1674, 0x27AC},
	{0x18F2, 0x9050, 0x8359, 0x097D, 0x0ABE, 0x72E0, 0x1674, 0x27AC},
	{0x18F2, 0x1674, 0x27AC, 0xA188, 0x8359, 0x097D, 0x0ABE},
	{0x9050, 0xA188, 0x65E9, 0x097D, 0x0ABE, 0x18F2, 0x72E0, 0x1674, 0x27AC},
	{0x18F2, 0x1674, 0x27AC, 0x65E9, 0x097D, 0x0ABE},
	{0x65E9, 0x27AC, 0x0ABE, 0x0BFB},
	{0x65E9, 0x27AC, 0x0ABE, 0x0BFB, 0xA188, 0x9050, 0x72E0},
	{0x8359, 0xA188, 0x27AC, 0x0ABE, 0x0BFB},
	{0x9050, 0x8359, 0x0BFB, 0x0ABE, 0x27AC, 0x72E0},
	{0x65E9, 0x27AC, 0x0ABE, 0x0BFB, 0x9050, 0x849A, 0x18F2},
	{0xA188, 0x849A, 0x18F2, 0x72E0, 0x0BFB, 0x65E9, 0x27AC, 0x0ABE},
	{0x8359, 0xA188, 0x27AC, 0x0ABE, 0x0BFB, 0x9050, 0x849A, 0x18F2},
	{0x8359, 0x849A, 0x18F2, 0x72E0, 0x27AC, 0x0ABE, 0x0BFB},
	{0x65E9, 0x27AC, 0x0ABE, 0x849A, 0x8359},
	{0x65E9, 0x27AC, 0x0ABE, 0x849A, 0x8359, 0xA188, 0x9050, 0x72E0},
	{0xA188, 0x27AC, 0x0ABE, 0x849A},
	{0x72E0, 0x27AC, 0x0ABE, 0x849A, 0x9050},
	{0x9050, 0x8359, 0x65E9, 0x27AC, 0x0ABE, 0x18F2},
	{0x8359, 0x65E9, 0x27AC, 0x0ABE, 0x18F2, 0x72E0, 0xA188},
	{0x9050, 0xA188, 0x27AC, 0x0ABE, 0x18F2},
	{0x72E0, 0x27AC, 0x0ABE, 0x18F2},
	{0x0ABE, 0x0BFB, 0x65E9, 0x72E0, 0x1674},
	{0x9050, 0x1674, 0x0ABE, 0x0BFB, 0x65E9, 0xA188},
	{0x72E0, 0x1674, 0x0ABE, 0x0BFB, 0x8359, 0xA188},
	{0x0BFB, 0x8359, 0x9050, 0x1674, 0x0ABE},
	{0x0ABE, 0x0BFB, 0x65E9, 0x72E0, 0x1674, 0x9050, 0x849A, 0x18F2},
	{0x1674, 0x0ABE, 0x0BFB, 0x65E9, 0xA188, 0x849A, 0x18F2},
	{0x0ABE, 0x0BFB, 0x8359, 0xA188, 0x72E0, 0x1674, 0x9050, 0x849A, 0x18F2},
	{0x8359, 0x849A, 0x18F2, 0x1674, 0x0ABE, 0x0BFB},
	{0x72E0, 0x65E9, 0x8359, 0x849A, 0x0ABE, 0x1674},
	{0x65E9, 0xA188, 0x9050, 0x1674, 0x0ABE, 0x849A, 0x8359},
	{0x1674, 0x0ABE, 0x849A, 0xA188, 0x72E0},
	{0x9050, 0x1674, 0x0ABE, 0x849A},
	{0x0ABE, 0x18F2, 0x9050, 0x8359, 0x65E9, 0x72E0, 0x1674},
	{0xA188, 0x8359, 0x65E9, 0x18F2, 0x1674, 0x0ABE},
	{0xA188, 0x72E0, 0x1674, 0x0ABE, 0x18F2, 0x9050},
	{0x18F2, 0x1674, 0x0ABE},
	{0x18F2, 0x0BFB, 0x097D, 0x1674},
	{0x0BFB, 0x097D, 0x1674, 0x18F2, 0xA188, 0x9050, 0x72E0},
	{0x0BFB, 0x097D, 0x1674, 0x18F2, 0xA188, 0x65E9, 0x8359},
	{0x8359, 0x9050, 0x72E0, 0x65E9, 0x18F2, 0x0BFB, 0x097D, 0x1674},
	{0x0BFB, 0x097D, 0x1674, 0x9050, 0x849A},
	{0xA188, 0x849A, 0x0BFB, 0x097D, 0x1674, 0x72E0},
	{0x0BFB, 0x097D, 0x1674, 0x9050, 0x849A, 0xA188, 0x65E9, 0x8359},
	{0x849A, 0x0BFB, 0x097D, 0x1674, 0x72E0, 0x65E9, 0x8359},
	{0x849A, 0x8359, 0x097D, 0x1674, 0x18F2},
	{0x849A, 0x8359, 0x097D, 0x1674, 0x18F2, 0xA188, 0x9050, 0x72E0},
	{0x1674, 0x097D, 0x65E9, 0xA188, 0x849A, 0x18F2},
	{0x849A, 0x9050, 0x72E0, 0x65E9, 0x097D, 0x1674, 0x18F2},
	{0x8359, 0x097D, 0x1674, 0x9050},
	{0xA188, 0x8359, 0x097D, 0x1674, 0x72E0},
	{0x65E9, 0x097D, 0x1674, 0x9050, 0xA188},
	{0x65E9, 0x097D, 0x1674, 0x72E0},
	{0x27AC, 0x72E0, 0x18F2, 0x0BFB, 0x097D},
	{0xA188, 0x27AC, 0x097D, 0x0BFB, 0x18F2, 0x9050},
	{0x27AC, 0x72E0, 0x18F2, 0x0BFB, 0x097D, 0xA188, 0x65E9, 0x8359},
	{0x27AC, 0x65E9, 0x8359, 0x9050, 0x18F2, 0x0BFB, 0x097D},
	{0x849A, 0x0BFB, 0x097D, 0x27AC, 0x72E0, 0x9050},
	{0x097D, 0x27AC, 0xA188, 0x849A, 0x0BFB},
	{0x27AC, 0x72E0, 0x9050, 0x849A, 0x0BFB, 0x097D, 0x8359, 0xA188, 0x65E9},
	{0x849A, 0x0BFB, 0x097D, 0x27AC, 0x65E9, 0x8359},
	{0x8359, 0x097D, 0x27AC, 0x72E0, 0x18F2, 0x849A},
	{0x18F2, 0x849A, 0x8359, 0x097D, 0x27AC, 0xA188, 0x9050},
	{0x097D, 0x27AC, 0x72E0, 0x18F2, 0x849A, 0xA188, 0x65E9},
	{0x9050, 0x18F2, 0x849A, 0x65E9, 0x097D, 0x27AC},
	{0x72E0, 0x9050, 0x8359, 0x097D, 0x27AC},
	{0x8359, 0x097D, 0x27AC, 0xA188},
	{0x9050, 0xA188, 0x65E9, 0x097D, 0x27AC, 0x72E0},
	{0x65E9, 0x097D, 0x27AC},
	{0x1674, 0x18F2, 0x0BFB, 0x65E9, 0x27AC},
	{0x1674, 0x18F2, 0x0BFB, 0x65E9, 0x27AC, 0xA188, 0x9050, 0x72E0},
	{0xA188, 0x27AC, 0x1674, 0x18F2, 0x0BFB, 0x8359},
	{0x27AC, 0x1674, 0x18F2, 0x0BFB, 0x8359, 0x9050, 0x72E0},
	{0x9050, 0x1674, 0x27AC, 0x65E9, 0x0BFB, 0x849A},
	{0x1674, 0x72E0, 0xA188, 0x849A, 0x0BFB, 0x65E9, 0x27AC},
	{0x0BFB, 0x8359, 0xA188, 0x27AC, 0x1674, 0x9050, 0x849A},
	{0x849A, 0x0BFB, 0x8359, 0x72E0, 0x27AC, 0x1674},
	{0x8359, 0x65E9, 0x27AC, 0x1674, 0x18F2, 0x849A},
	{0x1674, 0x18F2, 0x849A, 0x8359, 0x65E9, 0x27AC, 0xA188, 0x9050, 0x72E0},
	{0x18F2, 0x849A, 0xA188, 0x27AC, 0x1674},
	{0x849A, 0x9050, 0x72E0, 0x27AC, 0x1674, 0x18F2},
	{0x27AC, 0x1674, 0x9050, 0x8359, 0x65E9},
	{0x8359, 0x65E9, 0x27AC, 0x1674, 0x72E0, 0xA188},
	{0xA188, 0x27AC, 0x1674, 0x9050},
	{0x72E0, 0x27AC, 0x1674},
	{0x72E0, 0x18F2, 0x0BFB, 0x65E9},
	{0x9050, 0x18F2, 0x0BFB, 0x65E9, 0xA188},
	{0xA188, 0x72E0, 0x18F2, 0x0BFB, 0x8359},
	{0x9050, 0x18F2, 0x0BFB, 0x8359},
	{0x849A, 0x0BFB, 0x65E9, 0x72E0, 0x9050},
	{0xA188, 0x849A, 0x0BFB, 0x65E9},
	{0x72E0, 0x9050, 0x849A, 0x0BFB, 0x8359, 0xA188},
	{0x8359, 0x849A, 0x0BFB},
	{0x8359, 0x65E9, 0x72E0, 0x18F2, 0x849A},
	{0x18F2, 0x849A, 0x8359, 0x65E9, 0xA188, 0x9050},
	{0x72E0, 0x18F2, 0x849A, 0xA188},
	{0x9050, 0x18F2, 0x849A},
	{0x9050, 0x8359, 0x65E9, 0x72E0},
	{0xA188, 0x8359, 0x65E9},
	{0xA188, 0x72E0, 0x9050},
	{}
};

template<int cubeCountX, int cubeCountY, int cubeCountZ>
int8 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getCornerFieldValue(int x, int y, int z, int cornerIndex) {
	return field.get(x + (cornerIndex & 1), y + ((cornerIndex & 2) >> 1), z + ((cornerIndex & 4) >> 2));
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint32 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getCaseIndex(int x, int y, int z)
{
	uint32 value = 0;
	for (int i = 0; i < CORNER_COUNT; i++) {
		int8 vertexValue = getCornerFieldValue(x, y, z, i);
		uint32 vertexSign = vertexValue & 0x80;
		vertexSign;
		uint32 debug = vertexSign >> (7 - i);
		value |= vertexSign >> (7 - i);
	}
	return value;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint32 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getCornerDeltaMask(int x, int y, int z)
{
	uint32 xMask = (x == 0) ? 0 : 1;
	uint32 yMask = (y == 0) ? 0 : 2;
	uint32 zMask = (z == 0) ? 0 : 4;
	return (xMask | yMask | zMask);
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint32 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getEdgeDeltaMask(int x, int y, int z)
{
	uint32 xMask = (x == 0) ? 0 : 1;
	uint32 yMask = (y == 0) ? 0 : 6;
	uint32 zMask = (z == 0) ? 0 : 8;
	return (xMask | yMask | zMask);
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
int32 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getInterpolationT(int x, int y, int z, OnEdgeVertexCode code)
{
	int32 fieldValue0 = getCornerFieldValue(x, y, z, code.parts.lowerNumberedCorner);
	int32 fieldValue1 = getCornerFieldValue(x, y, z, code.parts.higherNumberedCorner);
	int32 interpolationT = (fieldValue1 << 8) / (fieldValue1 - fieldValue0);
	return interpolationT;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
void MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::ReusableCubeData::reset() {
	for (int i = 0; i < REUSABLE_CORNER_COUNT; i++) {
		corner[i] = BLANK;
	}
	for (int i = 0; i < REUSABLE_EDGE_COUNT; i++) {
		edge[i] = BLANK;
	}
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
void MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::ReusableCubeData::setCorner(uint8 cornerIndex, uint16 value) {
	if (cornerIndex >= (CORNER_COUNT - REUSABLE_CORNER_COUNT)) {
		corner[cornerIndex - (CORNER_COUNT - REUSABLE_CORNER_COUNT)] = value;
	}
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint16 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::ReusableCubeData::getCorner(uint8 cornerIndex) {
	if (cornerIndex >= (CORNER_COUNT - REUSABLE_CORNER_COUNT)) {
		return corner[cornerIndex - (CORNER_COUNT - REUSABLE_CORNER_COUNT)];
	}
	return BLANK;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
void MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::ReusableCubeData::setEdge(uint8 edgeIndex, uint16 value) {
	if (edgeIndex >= (EDGE_COUNT - REUSABLE_EDGE_COUNT)) {
		edge[edgeIndex - (EDGE_COUNT - REUSABLE_EDGE_COUNT)] = value;
	}
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint16 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::ReusableCubeData::getEdge(uint8 edgeIndex) {
	if (edgeIndex >= (EDGE_COUNT - REUSABLE_EDGE_COUNT)) {
		return edge[edgeIndex - (EDGE_COUNT - REUSABLE_EDGE_COUNT)];
	}
	return BLANK;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
void MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::setVertex(uint16 vertexIndex, float xPos, float yPos, float zPos)
{
	vertex[vertexIndex].position.x = xPos;
	vertex[vertexIndex].position.y = yPos;
	vertex[vertexIndex].position.z = zPos;
	// TODO set normal, tangent, and texcoord
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
bool MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::isTriangleAreaZero(int triangleIndex)
{
	if (triangle[triangleIndex].index[0] == triangle[triangleIndex].index[1]) {
		return true;
	}
	if (triangle[triangleIndex].index[0] == triangle[triangleIndex].index[2]) {
		return true;
	}
	if (triangle[triangleIndex].index[1] == triangle[triangleIndex].index[2]) {
		return true;
	}
	return false;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint16 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getNewVertexIndexOnCorner(int x, int y, int z, uint8 cornerIndex) {
	float xPos = cubeScale.x * (x + ((cornerIndex >> 0) & 1));
	float yPos = cubeScale.y * (y + ((cornerIndex >> 1) & 1));
	float zPos = cubeScale.z * (z + ((cornerIndex >> 2) & 1));
	setVertex(vertexCount, xPos, yPos, zPos);
	return vertexCount++;
}


template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint16 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getVertexIndexOnCorner(int x, int y, int z, OnEdgeVertexCode code, int32 interpolationT, typename ReusableCubeData deck[2][cubeCountX][cubeCountY]) {
	uint32 deltaMask = getCornerDeltaMask(x, y, z);
	uint8 cornerIndex = ((interpolationT == 0) ? code.parts.lowerNumberedCorner : code.parts.higherNumberedCorner);
	uint16 delta = cornerIndex ^ 7;
	uint16 maskedDelta = delta & deltaMask;
	cornerIndex += maskedDelta;
	x -= ((maskedDelta >> 0) & 1);
	y -= ((maskedDelta >> 1) & 1);
	z -= ((maskedDelta >> 2) & 1);
	uint16 vertexIndex = deck[z & 1][x][y].getCorner(cornerIndex);
	if (vertexIndex == ReusableCubeData::BLANK) {
		vertexIndex = getNewVertexIndexOnCorner(x, y, z, cornerIndex);
		deck[z & 1][x][y].setCorner(cornerIndex, vertexIndex);
	}
	return vertexIndex;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint16 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getNewVertexIndexOnEdge(int x, int y, int z, OnEdgeVertexCode code, int32 interpolationT) {
	float interpolatedX = (((code.parts.lowerNumberedCorner >> 0) & 1) * interpolationT + ((code.parts.higherNumberedCorner >> 0) & 1) * (0x0100 - interpolationT)) / 256.0;
	float interpolatedY = (((code.parts.lowerNumberedCorner >> 1) & 1) * interpolationT + ((code.parts.higherNumberedCorner >> 1) & 1) * (0x0100 - interpolationT)) / 256.0;
	float interpolatedZ = (((code.parts.lowerNumberedCorner >> 2) & 1) * interpolationT + ((code.parts.higherNumberedCorner >> 2) & 1) * (0x0100 - interpolationT)) / 256.0;
	float xPos = cubeScale.x * (x + interpolatedX);
	float yPos = cubeScale.y * (y + interpolatedY);
	float zPos = cubeScale.z * (z + interpolatedZ);
	setVertex(vertexCount, xPos, yPos, zPos);
	return 	vertexCount++;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
uint16 MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::getVertexIndexOnEdge(int x, int y, int z, OnEdgeVertexCode code, int32 interpolationT, typename ReusableCubeData deck[2][cubeCountX][cubeCountY]) {
	uint32 deltaMask = getEdgeDeltaMask(x, y, z);
	uint32 edgeDelta = code.parts.edgeDelta;
	uint16 edgeIndex = code.parts.edgeIndex;
	uint16 maskedDelta = edgeDelta & deltaMask;
	edgeIndex += (maskedDelta & 1) * 3 + ((maskedDelta >> 1) & 1) * 3 + ((maskedDelta >> 2) & 1) * 3 + ((maskedDelta >> 3) & 1) * 6;
	x -= ((maskedDelta >> 0) & 1);
	y -= ((maskedDelta >> 1) & 1);
	z -= ((maskedDelta >> 3) & 1);
	uint16 vertexIndex = deck[z & 1][x][y].getEdge(edgeIndex);
	if (vertexIndex == ReusableCubeData::BLANK) {
		vertexIndex = getNewVertexIndexOnEdge(x, y, z, code, interpolationT);
		deck[z & 1][x][y].setEdge(edgeIndex, vertexIndex);
	}
	return vertexIndex;
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
void MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::marchCube(int x, int y, int z, typename ReusableCubeData deck[2][cubeCountX][cubeCountY])
{
	deck[z & 1][x][y].reset();
	uint16 cubeVertexIndex[MAX_VERTEX_PER_CUBE];
	uint32 caseIndex = this->getCaseIndex(x, y, z);
	uint8 classIndex = caseIndexToClassIndex[caseIndex];
	ClassGeometry geometry = classGeometry[classIndex];
	for (int i = 0; i < geometry.geometryCounts.vertexCount; i++) {
		OnEdgeVertexCode code = onEdgeVertexCode[caseIndex][i];
		int32 interpolationT = getInterpolationT(x, y, z, code);
		if (interpolationT == 0 || interpolationT == 0x0100) {
			cubeVertexIndex[i] = getVertexIndexOnCorner(x, y, z, code, interpolationT, deck);
		}
		else {
			cubeVertexIndex[i] = getVertexIndexOnEdge(x, y, z, code, interpolationT, deck);
		}
	}
	for (int i = 0; i < geometry.geometryCounts.triangleCount; i++) {
		for (int j = 0; j < 3; j++) {
			triangle[triangleCount].index[j] = cubeVertexIndex[geometry.vertexIndex[3 * i + j]];
		}
		if (!isTriangleAreaZero(triangleCount)) {
			triangleCount++;
		}
	}
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
void MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::marchCubes()
{
	ReusableCubeData reusableCubeData[2][cubeCountX][cubeCountY];
	for (int k = 0; k < cubeCountZ; k++) {
		for (int j = 0; j < cubeCountY; j++) {
			for (int i = 0; i < cubeCountX; i++) {
				marchCube(i, j, k, reusableCubeData);
			}
		}
	}
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::MarchedGeometry(Vector3D cubeScale, VolumetricData<cubeCountX + 1, cubeCountY + 1, cubeCountZ + 1, int8>_field) : field(_field)
{
	this->cubeScale = cubeScale;
	this->size = Vector3D(cubeScale.x * cubeCountX, cubeScale.y * cubeCountY, cubeScale.z * cubeCountZ);
	vertexCount = 0;
	triangleCount = 0;
	marchCubes();
}

template<int cubeCountX, int cubeCountY, int cubeCountZ>
MarchedGeometry<cubeCountX, cubeCountY, cubeCountZ>::~MarchedGeometry()
{
}